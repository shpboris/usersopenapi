1.
Python Web application ecosystem

1.1
WSGI protocol - specifies the integration between a webserver and Python app.
Like servlet spec in Java.

1.2
WSGI server - handles end user HTTP requests and forwards them to WSGI-capable Python application
via WSGI protocol (seems like it is a code level protocol). WSGI server is like servlet container in Java web development.
There are many WSGI servers - Gunicorn, Waitress (analogy of Tomcat or Jetty in Java).
In this code I use Waitress as it is pure Python app that can
run also on Windows.

1.3
Werkzeug - library that helps to implement application side of WSGI protocol.

1.4
Flask - a framework for Web development like Spring MVC.
Uses Werkzeug to  implement WSGI protocol.

1.5
OpenAPI generator plugin - allows client and server code generation based on OpenAPI spec yaml files.

1.6
Connexion - performs request routing and input validation based on OpenAPI spec yaml files


2.
Code generation and running instructions

2.1
install node/npm

2.2
C:\Users\shpilb>npm install @openapitools/openapi-generator-cli -g

2.3
C:\py-branches\usersopenapi>python -m venv venv

2.4
C:\py-branches\usersopenapi\venv\Scripts>activate.bat

(venv) C:\py-branches\usersopenapi\venv\Scripts>

2.5
Put your openapi.yml to C:\py-branches\usersopenapi

Adjust location of the users_controller that is going to be generated accordingly to your custom package structure - api.spec.v1.openapi_server.
For this, add the following to your openapi.yml file.
x-openapi-router-controller: api.spec.v1.openapi_server.controllers.users_controller

2.6
(venv) C:\py-branches\usersopenapi>openapi-generator-cli generate -i .\api\spec\v1\openapi.yaml -g python-flask -o .\api\spec\v1

The option of setting the package name is unfortunately ignored: --package-name api.spec.v1.openapi_server.
So needs to change imports manually (see #7 below).

To avoid overriding existing generated files use --skip-overwrite option like in example below
openapi-generator-cli generate -i .\api\spec\v1\openapi.yaml -g python-flask -o .\api\spec\v1 --skip-overwrite

2.7
(venv) C:\py-branches\usersopenapi\api\spec\v1>pip install -r requirements.txt

2.8
Change import statements to use api.spec.v1.openapi_server instead of openapi_server
[Pay attention that - url: / part in openapi.yml controls the path on which swagger ui (may be also API) will be available]

2.9
Access the Swagger UI on http://127.0.0.1:8080/ui/

3.
Python packaging and build system

Python serves as a "frontend" build tool that reads the pyproject.toml and interacts with
"backend" build tool like setuptools or flit or poetry to produce deployable artifact (wheel)
in a form of zipped file with .whl extension.

[Pay attention, that python might have multiple versions installed on a machine, so py tool is used
to manage those versions - i.e define default version, invoke default version, run with specified version etc.]

Then to upload a wheel to a central repo PyPI or install it locally, you can use package manager - pip.
Some modern tools like poetry and flit can manage all lifecycle - create wheel, upload to PyPI and install locally.

4.
Creating and deploying wheel

4.1
Create myvenv

C:\py-branches\usersopenapi>python -m venv myvenv
C:\py-branches\usersopenapi\myvenv\Scripts>activate.bat

4.2
Instal build module

pip install build

4.3
Create a wheel

(myvenv) C:\py-branches\usersopenapi>py -m build

This will produce a dist directory with those file
C:\py-branches\usersopenapi\dist\usersopenapi-0.0.1-py3-none-any.whl
C:\py-branches\usersopenapi\dist\usersopenapi-0.0.1.tar.gz

4.4
Install a wheel

(myvenv) C:\py-branches\usersopenapi>pip install dist\usersopenapi-0.0.1-py3-none-any.whl

4.5
Run a wheel as a module (whatever it means)

(myvenv) C:\py-branches\usersopenapi>py -m api.spec.v1.openapi_server

It is also possible to run like a script (whatever it means):

(myvenv) C:\py-branches\usersopenapi>py api/spec/v1/openapi_server

Options above work because openapi_server contains __main__.py file which is a special
executable Python file within a package.

5.
Observations from wheel creation and deployment

5.1
The pyproject.toml references C:\py-branches\usersopenapi\requirements.txt file for figuring out dependencies.
This is a relevant line in pyproject.toml- dependencies = {file = ["requirements.txt"]}

To create this requirements.txt I installed requirements file (in myvenv environment)
that was generated by Open API generator  -
C:\py-branches\usersopenapi\api\spec\v1\requirements.txt
The instal command: pip install -r requirements.txt

And then added additional packages like waitress etc to myvenv

And finally executed the following in myvenv environment to get all dependencies
pip freeze > requirements.txt

5.2
The usual way to specify dependencies in pyproject.toml is the following (instead of using requirements.txt hack)

dependencies = [
    "feedparser >= 5.2.0",
    "html2text",
    'tomli; python_version < "3.11"',
]

5.3
Your wheel is installed to a location under site-packages folder like this:
C:\py-branches\usersopenapi\myvenv2\Lib\site-packages\api\spec\v1

The site-packages is added to PYTHONPATH so running the following works from any directory because
package path is appened to C:\py-branches\usersopenapi\myvenv2\Lib\site-packages
py -m api.spec.v1.openapi_server

5.4
Setuptools is configured in this exercise using this line in pyproject.toml
requires = ["setuptools>=61.0", "wheel"]

5.5
To add the logging config yaml the following is used in pyproject.toml

[tool.setuptools.package-data]
"*" = ["*.yaml"]

5.6
Whenever encountered the following error
This was used to get rid of "Multiple top-level packages discovered in a flat-layout: ['api', 'myvenv']"

Add this to the pyproject.toml and build (or deploy ?) wheel once
[tool.setuptools]
py-modules = []

Then remove this snippet and build/deploy wheel again

6.
Resources for creating/deploying wheels

6.1
Creating wheels - this one was main source for this exercise
https://packaging.python.org/en/latest/tutorials/packaging-projects/

6.2
Installing wheels
https://packaging.python.org/en/latest/tutorials/installing-packages/#creating-and-using-virtual-environments

6.3
Great info on flit
https://betterprogramming.pub/a-pyproject-toml-developers-cheat-sheet-5782801fb3ed

6.4
In depth info
https://realpython.com/pypi-publish-python-package/#flit

7.
Creating and deploying docker image to K8s

nerdctl login
nerdctl --namespace k8s.io build -t shpboris/usersopenapi .
nerdctl --namespace k8s.io push shpboris/usersopenapi
kubectl apply -f deploy/deployment.yaml
kubectl apply -f deploy/service.yaml

For troubleshooting image issues use this instruction to get the image's tar file
C:\py-branches\usersopenapi>nerdctl --namespace k8s.io save shpboris/usersopenapi > my-image.tar

The my-image.tar will be saved in the current directory (i.e in C:\py-branches\usersopenapi in this example)

8.
Using mountable code

The general idea is to mount a code located on Windows to the pod - then after code change
on Windows and restart of the pod, the new code is running immediately without the need to create an image.

The code in Windows is accessible because the Kubernetes is running in WSL!

In order to execute this scenario, use same instructions like in 7 above but instead of:
kubectl apply -f deploy/deployment.yaml

use kubectl apply -f deploy/deployment-with-code-mount.yaml

This is how the path of the code on local Windows is defined -

  volumes:
  - name: code-volume
    hostPath:
      path: /mnt/c/py-branches/usersopenapi

This is how it is mounted to /usersopenapi within the Pod - i.e exactly to the place where entry point defined in
Dockerfile expects to find it:

  volumeMounts:
  - name: code-volume
    mountPath: /usersopenapi

More specifically, the WORKDIR in Dockerfile is /usersopenapi and the entry point
is CMD ["python", "-m", "api.spec.v1.openapi_server"]

Meaning, the expectation is to find the __main__.py under /usersopenapi/api/spec/v1/openapi_server.
Therefore we map /usersopenapi within Pod to /mnt/c/py-branches/usersopenapi and then __main__.py
is found under /mnt/c/py-branches/usersopenapi/api/spec/v1/openapi_server on Windows !
